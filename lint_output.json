[{"filePath":"D:\\coding\\projects\\website-quiz\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\App.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\components\\QuestionForm\\index.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\components\\QuizCard.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\components\\QuizCardSkeleton.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\components\\ui\\Button.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\components\\ui\\Input.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\context\\QuizContext.jsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Move your React context(s) to a separate file.","line":3,"column":14,"nodeType":"Identifier","messageId":"reactContext","endLine":3,"endColumn":25},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n  14 |     if (storedQuizzes) {\n  15 |       try {\n> 16 |         setQuizzes(JSON.parse(storedQuizzes));\n     |         ^^^^^^^^^^ Avoid calling setState() directly within an effect\n  17 |       } catch (error) {\n  18 |         console.error(\"Failed to parse quizzes:\", error);\n  19 |         setQuizzes([]);","line":16,"column":9,"nodeType":null,"endLine":16,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createContext, useState, useEffect, useCallback } from \"react\";\r\n\r\nexport const QuizContext = createContext();\r\n\r\nconst STORAGE_KEY = \"quiz-app-data\";\r\n\r\nexport const QuizProvider = ({ children }) => {\r\n  const [quizzes, setQuizzes] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  // Load quizzes on mount\r\n  useEffect(() => {\r\n    const storedQuizzes = localStorage.getItem(STORAGE_KEY);\r\n    if (storedQuizzes) {\r\n      try {\r\n        setQuizzes(JSON.parse(storedQuizzes));\r\n      } catch (error) {\r\n        console.error(\"Failed to parse quizzes:\", error);\r\n        setQuizzes([]);\r\n      }\r\n    }\r\n    setLoading(false);\r\n  }, []); // Run only once on mount\r\n\r\n  // Save quizzes when they change\r\n  useEffect(() => {\r\n    if (!loading) {\r\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(quizzes));\r\n    }\r\n  }, [quizzes, loading]);\r\n\r\n  const addQuiz = useCallback((quiz) => {\r\n    const newQuiz = {\r\n      ...quiz,\r\n      id: Date.now().toString(),\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n    setQuizzes((prev) => [...prev, newQuiz]);\r\n    return newQuiz.id;\r\n  }, []);\r\n\r\n  const deleteQuiz = useCallback((id) => {\r\n    setQuizzes((prev) => prev.filter((q) => q.id !== id));\r\n  }, []);\r\n\r\n  // Helper to get a specific quiz\r\n  const getQuiz = useCallback(\r\n    (id) => {\r\n      return quizzes.find((q) => q.id === id);\r\n    },\r\n    [quizzes],\r\n  );\r\n\r\n  const value = {\r\n    quizzes,\r\n    loading,\r\n    addQuiz,\r\n    deleteQuiz,\r\n    getQuiz,\r\n  };\r\n\r\n  return <QuizContext.Provider value={value}>{children}</QuizContext.Provider>;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\hooks\\useDebounce.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\hooks\\useQuizzes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\hooks\\useTimer.js","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n  15 |\n  16 |     // Set initial seconds\n> 17 |     setTimeLeft(initialMinutes * 60);\n     |     ^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  18 |\n  19 |     const intervalId = setInterval(() => {\n  20 |       setTimeLeft((prev) => {","line":17,"column":5,"nodeType":null,"endLine":17,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef } from \"react\";\r\n\r\nconst useTimer = (initialMinutes, onTimeUp) => {\r\n  const [timeLeft, setTimeLeft] = useState(0);\r\n  const onTimeUpRef = useRef(onTimeUp);\r\n\r\n  // Ensure callback is always fresh without restarting timer\r\n  useEffect(() => {\r\n    onTimeUpRef.current = onTimeUp;\r\n  }, [onTimeUp]);\r\n\r\n  // Start/Restart timer when initialMinutes changes\r\n  useEffect(() => {\r\n    if (!initialMinutes || initialMinutes <= 0) return;\r\n\r\n    // Set initial seconds\r\n    setTimeLeft(initialMinutes * 60);\r\n\r\n    const intervalId = setInterval(() => {\r\n      setTimeLeft((prev) => {\r\n        // Build-in check: if we're at 1 second, next tick is 0, so stop.\r\n        if (prev <= 1) {\r\n          clearInterval(intervalId);\r\n          if (onTimeUpRef.current) {\r\n            onTimeUpRef.current();\r\n          }\r\n          return 0;\r\n        }\r\n        return prev - 1;\r\n      });\r\n    }, 1000);\r\n\r\n    // Cleanup on unmount or re-run\r\n    return () => clearInterval(intervalId);\r\n  }, [initialMinutes]);\r\n\r\n  const formatTime = (seconds) => {\r\n    const min = Math.floor(seconds / 60);\r\n    const sec = seconds % 60;\r\n    return `${min}:${sec < 10 ? \"0\" : \"\"}${sec}`;\r\n  };\r\n\r\n  return { timeLeft, formatTime };\r\n};\r\n\r\nexport default useTimer;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\main.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\pages\\QuizAttempt\\index.jsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n  20 |       const foundQuiz = getQuiz(id);\n  21 |       if (foundQuiz) {\n> 22 |         setQuiz(foundQuiz);\n     |         ^^^^^^^ Avoid calling setState() directly within an effect\n  23 |       } else {\n  24 |         navigate(\"/\");\n  25 |       }","line":22,"column":9,"nodeType":null,"endLine":22,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from \"react\";\r\nimport { useParams, useNavigate } from \"react-router-dom\";\r\nimport { useQuizzes } from \"../../hooks/useQuizzes\";\r\nimport useTimer from \"../../hooks/useTimer\";\r\nimport Button from \"../../components/ui/Button\";\r\nimport \"./style.scss\";\r\n\r\nconst QuizAttempt = () => {\r\n  const { id } = useParams();\r\n  const navigate = useNavigate();\r\n  const { getQuiz, loading } = useQuizzes();\r\n  const [quiz, setQuiz] = useState(null);\r\n  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\r\n  const [answers, setAnswers] = useState({}); // { questionIndex: [selectedOptionIndex] }\r\n  const [isSubmitted, setIsSubmitted] = useState(false);\r\n\r\n  // Load Quiz\r\n  useEffect(() => {\r\n    if (!loading && !quiz) {\r\n      const foundQuiz = getQuiz(id);\r\n      if (foundQuiz) {\r\n        setQuiz(foundQuiz);\r\n      } else {\r\n        navigate(\"/\");\r\n      }\r\n    }\r\n  }, [id, loading, getQuiz, navigate, quiz]);\r\n\r\n  // Submit Quiz - Using useCallback to ensure stable reference\r\n\r\n  // Handle Time Up\r\n  const handleTimeUp = useCallback(() => {\r\n    if (!isSubmitted) {\r\n      // Direct navigation for time up\r\n      navigate(`/result/${id}`, {\r\n        state: {\r\n          quiz,\r\n          answers,\r\n          timeLeft: 0,\r\n          totalTime: quiz.timeLimit * 60,\r\n          autoSubmitted: true,\r\n        },\r\n      });\r\n    }\r\n  }, [id, isSubmitted, navigate, quiz, answers]);\r\n\r\n  // Timer Hook\r\n  const { timeLeft, formatTime } = useTimer(\r\n    quiz ? quiz.timeLimit : 0,\r\n    handleTimeUp,\r\n  );\r\n\r\n  // Manual Submit wrapper to include timeLeft\r\n  const handleManualSubmit = () => {\r\n    if (isSubmitted) return;\r\n    setIsSubmitted(true);\r\n    navigate(`/result/${id}`, {\r\n      state: {\r\n        quiz,\r\n        answers,\r\n        timeLeft, // Pass current timeLeft\r\n        totalTime: quiz.timeLimit * 60,\r\n        autoSubmitted: false,\r\n      },\r\n    });\r\n  };\r\n\r\n  const handleAnswer = (optionIndex, isMulti) => {\r\n    setAnswers((prev) => {\r\n      const currentAnswers = prev[currentQuestionIndex] || [];\r\n      let newAnswers;\r\n\r\n      if (isMulti) {\r\n        if (currentAnswers.includes(optionIndex)) {\r\n          newAnswers = currentAnswers.filter((i) => i !== optionIndex);\r\n        } else {\r\n          newAnswers = [...currentAnswers, optionIndex];\r\n        }\r\n      } else {\r\n        newAnswers = [optionIndex];\r\n      }\r\n\r\n      return {\r\n        ...prev,\r\n        [currentQuestionIndex]: newAnswers,\r\n      };\r\n    });\r\n  };\r\n\r\n  if (loading || !quiz) {\r\n    return <div className=\"loading-screen\">Loading Quiz...</div>;\r\n  }\r\n\r\n  const currentQuestion = quiz.questions[currentQuestionIndex];\r\n\r\n  // Guard clause if questions are missing for some reason\r\n  if (!currentQuestion) {\r\n    return <div>Error loading question.</div>;\r\n  }\r\n\r\n  const isLastQuestion = currentQuestionIndex === quiz.questions.length - 1;\r\n  const currentAnswers = answers[currentQuestionIndex] || [];\r\n\r\n  // FEATURE: Flash alert when time is low\r\n  const isWarning = timeLeft <= 10;\r\n\r\n  return (\r\n    <div\r\n      className={`quiz-attempt-page ${isWarning ? \"timer-flash-container\" : \"\"}`}\r\n    >\r\n      <header className=\"quiz-header\">\r\n        <h2>{quiz.title}</h2>\r\n        <div className={`timer ${isWarning ? \"warning\" : \"\"}`}>\r\n          Time Left: {formatTime(timeLeft)}\r\n        </div>\r\n      </header>\r\n\r\n      <div className=\"progress-bar\">\r\n        <div\r\n          className=\"progress-fill\"\r\n          style={{\r\n            width: `${((currentQuestionIndex + 1) / quiz.questions.length) * 100}%`,\r\n          }}\r\n        ></div>\r\n      </div>\r\n\r\n      <div className=\"question-container\">\r\n        <div className=\"question-header\">\r\n          <span className=\"q-number\">\r\n            Question {currentQuestionIndex + 1} of {quiz.questions.length}\r\n          </span>\r\n          <h3 className=\"q-text\">{currentQuestion.questionText}</h3>\r\n          <span className=\"q-type\">\r\n            {currentQuestion.type === \"multiple\"\r\n              ? \"(Select all that apply)\"\r\n              : \"(Select one)\"}\r\n          </span>\r\n        </div>\r\n\r\n        <div className=\"options-list\">\r\n          {currentQuestion.options.map((option, idx) => (\r\n            <div\r\n              key={idx}\r\n              className={`option-item ${currentAnswers.includes(idx) ? \"selected\" : \"\"}`}\r\n              onClick={() =>\r\n                handleAnswer(idx, currentQuestion.type === \"multiple\")\r\n              }\r\n            >\r\n              <span className=\"opt-marker\">\r\n                {currentQuestion.type === \"single\" ? (\r\n                  <span\r\n                    className={`radio ${currentAnswers.includes(idx) ? \"checked\" : \"\"}`}\r\n                  ></span>\r\n                ) : (\r\n                  <span\r\n                    className={`checkbox ${currentAnswers.includes(idx) ? \"checked\" : \"\"}`}\r\n                  ></span>\r\n                )}\r\n              </span>\r\n              <span className=\"opt-text\">{option.text}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </div>\r\n\r\n      <footer className=\"quiz-footer\">\r\n        <Button\r\n          variant=\"secondary\"\r\n          onClick={() =>\r\n            setCurrentQuestionIndex((prev) => Math.max(0, prev - 1))\r\n          }\r\n          disabled={currentQuestionIndex === 0}\r\n        >\r\n          Previous\r\n        </Button>\r\n\r\n        {isLastQuestion ? (\r\n          <Button variant=\"success\" onClick={handleManualSubmit}>\r\n            Submit Quiz\r\n          </Button>\r\n        ) : (\r\n          <Button\r\n            onClick={() =>\r\n              setCurrentQuestionIndex((prev) =>\r\n                Math.min(quiz.questions.length - 1, prev + 1),\r\n              )\r\n            }\r\n          >\r\n            Next\r\n          </Button>\r\n        )}\r\n      </footer>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default QuizAttempt;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\pages\\QuizCreate\\index.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\pages\\QuizList\\index.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\src\\pages\\QuizResult\\index.jsx","messages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":17,"column":19,"nodeType":"Identifier","endLine":17,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from \"react\";\r\nimport { useLocation, Link, Navigate, useParams } from \"react-router-dom\";\r\nimport Button from \"../../components/ui/Button\";\r\nimport \"./style.scss\";\r\n\r\nconst QuizResult = () => {\r\n  const { id } = useParams();\r\n  const location = useLocation();\r\n\r\n  // Check if result data exists\r\n  if (!location.state) {\r\n    return <Navigate to=\"/\" replace />;\r\n  }\r\n\r\n  const { quiz, answers, timeLeft, totalTime, autoSubmitted } = location.state;\r\n\r\n  const results = useMemo(() => {\r\n    let correctCount = 0;\r\n    const total = quiz.questions.length;\r\n\r\n    const breakdown = quiz.questions.map((q, index) => {\r\n      const userAns = answers[index] || [];\r\n      const correctOptIndices = q.options\r\n        .map((opt, i) => (opt.isCorrect ? i : -1))\r\n        .filter((i) => i !== -1);\r\n\r\n      let isCorrect = false;\r\n\r\n      if (q.type === \"single\") {\r\n        // User answer is array for consistency, take first\r\n        const singleAns = userAns.length > 0 ? userAns[0] : -1;\r\n        isCorrect = correctOptIndices.includes(singleAns);\r\n      } else {\r\n        // Multiple choice: exact match of sorted indices\r\n        const sortedUser = [...userAns].sort();\r\n        const sortedCorrect = [...correctOptIndices].sort();\r\n        isCorrect =\r\n          JSON.stringify(sortedUser) === JSON.stringify(sortedCorrect);\r\n      }\r\n\r\n      if (isCorrect) correctCount++;\r\n\r\n      return {\r\n        question: q,\r\n        userAns,\r\n        correctOptIndices,\r\n        isCorrect,\r\n      };\r\n    });\r\n\r\n    const percentage = Math.round((correctCount / total) * 100);\r\n\r\n    // FEATURE: Motivational feedback based on score (from simplified version)\r\n    let message = \"\";\r\n    if (percentage >= 80) message = \"Excellent Work! ≡ƒîƒ\";\r\n    else if (percentage >= 50) message = \"Good Job! ≡ƒæì\";\r\n    else message = \"Better Luck Next Time! ≡ƒÆ¬\";\r\n\r\n    return {\r\n      score: correctCount,\r\n      total,\r\n      percentage,\r\n      message,\r\n      breakdown,\r\n    };\r\n  }, [quiz, answers]);\r\n\r\n  const formatTime = (seconds) => {\r\n    const mins = Math.floor(seconds / 60);\r\n    const secs = seconds % 60;\r\n    return `${mins}m ${secs}s`;\r\n  };\r\n\r\n  const timeTaken = totalTime - timeLeft;\r\n\r\n  return (\r\n    <div className=\"quiz-result-page\">\r\n      <div className=\"result-card\">\r\n        <h1>Quiz Results</h1>\r\n        <h3>{quiz.title}</h3>\r\n\r\n        <div className=\"score-circle\">\r\n          <span className=\"percentage\">{results.percentage}%</span>\r\n          <span className=\"score-text\">\r\n            {results.score} / {results.total}\r\n          </span>\r\n        </div>\r\n\r\n        {/* Motivational Message */}\r\n        <h3\r\n          style={{\r\n            textAlign: \"center\",\r\n            margin: \"1rem 0\",\r\n            color: \"#333\",\r\n            fontSize: \"1.2rem\",\r\n          }}\r\n        >\r\n          {results.message}\r\n        </h3>\r\n\r\n        <div className=\"stats-grid\">\r\n          <div className=\"stat\">\r\n            <label>Time Taken</label>\r\n            <span>{formatTime(timeTaken)}</span>\r\n          </div>\r\n          <div className=\"stat\">\r\n            <label>Status</label>\r\n            <span className={results.percentage >= 50 ? \"pass\" : \"fail\"}>\r\n              {results.percentage >= 50 ? \"Passed\" : \"Failed\"}\r\n            </span>\r\n          </div>\r\n        </div>\r\n\r\n        {autoSubmitted && (\r\n          <div className=\"time-up-msg\">\r\n            Time's up! Your answers were automatically submitted.\r\n          </div>\r\n        )}\r\n\r\n        <div className=\"actions\">\r\n          <Link to=\"/\">\r\n            <Button variant=\"outline\">Back to Home</Button>\r\n          </Link>\r\n          <Link to={`/attempt/${id}`}>\r\n            <Button variant=\"primary\">Retake Quiz</Button>\r\n          </Link>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"breakdown-section\">\r\n        <h3>Detailed Analysis</h3>\r\n        {results.breakdown.map((item, idx) => (\r\n          <div\r\n            key={idx}\r\n            className={`question-review ${item.isCorrect ? \"correct\" : \"incorrect\"}`}\r\n          >\r\n            <div className=\"review-header\">\r\n              <span className=\"q-num\">Q{idx + 1}</span>\r\n              <h4>{item.question.questionText}</h4>\r\n              <span className=\"badge\">\r\n                {item.isCorrect ? \"Correct\" : \"Incorrect\"}\r\n              </span>\r\n            </div>\r\n            <div className=\"options-review\">\r\n              {item.question.options.map((opt, optIdx) => {\r\n                const isSelected = item.userAns.includes(optIdx);\r\n                const isCorrect = item.correctOptIndices.includes(optIdx); // Actually correct option\r\n\r\n                let className = \"opt-review\";\r\n                if (isSelected && isCorrect) className += \" user-correct\";\r\n                else if (isSelected && !isCorrect) className += \" user-wrong\";\r\n                else if (!isSelected && isCorrect) className += \" missed\";\r\n                else className += \" neutral\";\r\n\r\n                return (\r\n                  <div key={optIdx} className={className}>\r\n                    <span className=\"marker\">\r\n                      {isCorrect && \"Γ£ô\"}\r\n                      {isSelected && !isCorrect && \"Γ£ù\"}\r\n                      {!isSelected && !isCorrect && \"ΓÇó\"}\r\n                    </span>\r\n                    <span className=\"text\">{opt.text}</span>\r\n                    {isCorrect && (\r\n                      <span className=\"label\">(Correct Answer)</span>\r\n                    )}\r\n                    {isSelected && !isCorrect && (\r\n                      <span className=\"label\">(Your Answer)</span>\r\n                    )}\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default QuizResult;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\coding\\projects\\website-quiz\\vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
